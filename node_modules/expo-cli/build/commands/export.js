"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.action = action;
exports.default = _default;

function _config() {
  const data = require("@expo/config");

  _config = function () {
    return data;
  };

  return data;
}

function _xdl() {
  const data = require("@expo/xdl");

  _xdl = function () {
    return data;
  };

  return data;
}

function _crypto() {
  const data = _interopRequireDefault(require("crypto"));

  _crypto = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _got() {
  const data = _interopRequireDefault(require("got"));

  _got = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _stream() {
  const data = _interopRequireDefault(require("stream"));

  _stream = function () {
    return data;
  };

  return data;
}

function _tar() {
  const data = _interopRequireDefault(require("tar"));

  _tar = function () {
    return data;
  };

  return data;
}

function _util() {
  const data = require("util");

  _util = function () {
    return data;
  };

  return data;
}

function _validator() {
  const data = _interopRequireDefault(require("validator"));

  _validator = function () {
    return data;
  };

  return data;
}

function _CommandError() {
  const data = _interopRequireDefault(require("../CommandError"));

  _CommandError = function () {
    return data;
  };

  return data;
}

function _log() {
  const data = _interopRequireDefault(require("../log"));

  _log = function () {
    return data;
  };

  return data;
}

function _prompt() {
  const data = _interopRequireDefault(require("../prompt"));

  _prompt = function () {
    return data;
  };

  return data;
}

function _progress() {
  const data = require("./utils/progress");

  _progress = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const pipeline = (0, _util().promisify)(_stream().default.pipeline);
/**
 * Download a tar.gz file and extract it to a folder.
 *
 * @param url remote URL to download.
 * @param destination destination folder to extract the tar to.
 */

async function downloadAndDecompressAsync(url, destination) {
  const downloadStream = _got().default.stream(url).on('downloadProgress', (0, _progress().createProgressTracker)());

  await pipeline(downloadStream, _tar().default.extract({
    cwd: destination
  }));
  return destination;
}

async function action(projectDir, options) {
  var _options$target;

  if (!options.publicUrl) {
    throw new (_CommandError().default)('MISSING_PUBLIC_URL', 'Missing required option: --public-url');
  }

  const outputPath = _path().default.resolve(projectDir, options.outputDir);

  let overwrite = options.force;

  if (_fsExtra().default.existsSync(outputPath)) {
    if (!overwrite) {
      const question = {
        type: 'confirm',
        name: 'action',
        message: `Output directory ${outputPath} already exists.\nThe following files and directories will be overwritten if they exist:\n- ${options.outputDir}/bundles\n- ${options.outputDir}/assets\n- ${options.outputDir}/ios-index.json\n- ${options.outputDir}/android-index.json\nWould you like to continue?`
      };
      const {
        action
      } = await (0, _prompt().default)(question);

      if (action) {
        overwrite = true;
      } else {
        throw new (_CommandError().default)('OUTPUT_DIR_EXISTS', `Output directory ${outputPath} already exists. Aborting export.`);
      }
    }

    if (overwrite) {
      (0, _log().default)(`Removing old files from ${outputPath}`);

      const outputBundlesDir = _path().default.resolve(outputPath, 'bundles');

      const outputAssetsDir = _path().default.resolve(outputPath, 'assets');

      const outputAndroidJson = _path().default.resolve(outputPath, 'android-index.json');

      const outputiOSJson = _path().default.resolve(outputPath, 'ios-index.json');

      if (_fsExtra().default.existsSync(outputBundlesDir)) {
        _fsExtra().default.removeSync(outputBundlesDir);
      }

      if (_fsExtra().default.existsSync(outputAssetsDir)) {
        _fsExtra().default.removeSync(outputAssetsDir);
      }

      if (_fsExtra().default.existsSync(outputAndroidJson)) {
        _fsExtra().default.removeSync(outputAndroidJson);
      }

      if (_fsExtra().default.existsSync(outputiOSJson)) {
        _fsExtra().default.removeSync(outputiOSJson);
      }
    }
  } // If we are not in dev mode, ensure that url is https


  if (!options.dev && !_xdl().UrlUtils.isHttps(options.publicUrl)) {
    throw new (_CommandError().default)('INVALID_PUBLIC_URL', '--public-url must be a valid HTTPS URL.');
  } else if (!_validator().default.isURL(options.publicUrl, {
    protocols: ['http', 'https']
  })) {
    console.warn(`Dev Mode: publicUrl ${options.publicUrl} does not conform to HTTP format.`);
  } // Make outputDir an absolute path if it isnt already


  const exportOptions = {
    dumpAssetmap: options.dumpAssetmap,
    dumpSourcemap: options.dumpSourcemap,
    isDev: options.dev,
    publishOptions: {
      resetCache: !!options.clear,
      target: (_options$target = options.target) !== null && _options$target !== void 0 ? _options$target : (0, _config().getDefaultTarget)(projectDir)
    }
  };

  const absoluteOutputDir = _path().default.resolve(process.cwd(), options.outputDir);

  await _xdl().Project.exportForAppHosting(projectDir, options.publicUrl, options.assetUrl, absoluteOutputDir, exportOptions); // Merge src dirs/urls into a multimanifest if specified

  const mergeSrcDirs = []; // src urls were specified to merge in, so download and decompress them

  if (options.mergeSrcUrl.length > 0) {
    // delete .tmp if it exists and recreate it anew
    const tmpFolder = _path().default.resolve(projectDir, _path().default.join('.tmp'));

    await _fsExtra().default.remove(tmpFolder);
    await _fsExtra().default.ensureDir(tmpFolder); // Download the urls into a tmp dir

    const downloadDecompressPromises = options.mergeSrcUrl.map(async url => {
      // Add the absolute paths to srcDir
      const uniqFilename = `${_path().default.basename(url, '.tar.gz')}_${_crypto().default.randomBytes(16).toString('hex')}`;

      const tmpFolderUncompressed = _path().default.resolve(tmpFolder, uniqFilename);

      await _fsExtra().default.ensureDir(tmpFolderUncompressed);
      await downloadAndDecompressAsync(url, tmpFolderUncompressed); // add the decompressed folder to be merged

      mergeSrcDirs.push(tmpFolderUncompressed);
    });
    await Promise.all(downloadDecompressPromises);
  } // add any local src dirs to be merged


  mergeSrcDirs.push(...options.mergeSrcDir);

  if (mergeSrcDirs.length > 0) {
    const srcDirs = options.mergeSrcDir.concat(options.mergeSrcUrl).join(' ');
    (0, _log().default)(`Starting project merge of ${srcDirs} into ${options.outputDir}`); // Merge app distributions

    await _xdl().Project.mergeAppDistributions(projectDir, [...mergeSrcDirs, options.outputDir], // merge stuff in srcDirs and outputDir together
    options.outputDir);
    (0, _log().default)(`Project merge was successful. Your merged files can be found in ${options.outputDir}`);
  }

  (0, _log().default)(`Export was successful. Your exported files can be found in ${options.outputDir}`);
}

function collect(val, memo) {
  memo.push(val);
  return memo;
}

function _default(program) {
  program.command('export [path]').description('Export the static files of the app for hosting it on a web server').helpGroup('core').option('-p, --public-url <url>', 'The public url that will host the static files. (Required)').option('--output-dir <dir>', 'The directory to export the static files to. Default directory is `dist`', 'dist').option('-a, --asset-url <url>', "The absolute or relative url that will host the asset files. Default is './assets', which will be resolved against the public-url.", './assets').option('-d, --dump-assetmap', 'Dump the asset map for further processing.').option('--dev', 'Configure static files for developing locally using a non-https server').option('-f, --force', 'Overwrite files in output directory without prompting for confirmation').option('-s, --dump-sourcemap', 'Dump the source map for debugging the JS bundle.').option('-q, --quiet', 'Suppress verbose output.').option('-t, --target [env]', 'Target environment for which this export is intended. Options are `managed` or `bare`.').option('--merge-src-dir [dir]', 'A repeatable source dir to merge in.', collect, []).option('--merge-src-url [url]', 'A repeatable source tar.gz file URL to merge in.', collect, []).option('--max-workers [num]', 'Maximum number of tasks to allow Metro to spawn.').asyncActionProjectDir(action, {
    checkConfig: true
  });
}
//# sourceMappingURL=export.js.map